import os
import re
import json
import sys
import time
import tkinter as tk
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload
from tkinter import filedialog, simpledialog, scrolledtext, messagebox

def obter_dados_via_gui():
    root = tk.Tk()
    root.title("Agente Colab")
    root.geometry("600x500")
    
    # Link do Colab
    tk.Label(root, text="Link do Google Colab:", anchor="w").pack(fill="x", padx=10, pady=(10,0))
    link_var = tk.StringVar()
    tk.Entry(root, textvariable=link_var).pack(fill="x", padx=10)

    # Texto da aula
    tk.Label(root, text="Cole aqui a aula (Ctrl+V):", anchor="w").pack(fill="x", padx=10, pady=(10,0))
    texto_widget = scrolledtext.ScrolledText(root, wrap=tk.WORD, height=15)
    texto_widget.pack(fill="both", expand=True, padx=10, pady=(0,10))

    def iniciar():
        link = link_var.get().strip()
        conteudo = texto_widget.get("1.0", tk.END).strip()
        if not link or not conteudo:
            messagebox.showerror("Erro", "Preencha o link e cole o texto da aula antes de continuar.")
            return
        root.destroy()
        # Vari√°veis globais que o main() vai usar
        global GUI_LINK, GUI_AULA
        GUI_LINK = link
        GUI_AULA = conteudo

    tk.Button(root, text="Iniciar", command=iniciar).pack(pady=(0,10))
    root.mainloop()

# Escopos de permiss√£o: Acesso total ao Google Drive
SCOPES = ['https://www.googleapis.com/auth/drive']
CLIENT_SECRETS_FILE = 'client_secrets.json'

def check_requirements():
    """Verifica se todos os arquivos necess√°rios est√£o presentes."""
    print("üîç Verificando arquivos necess√°rios...")
    
    if not os.path.exists(CLIENT_SECRETS_FILE):
        print(f"‚ùå Arquivo '{CLIENT_SECRETS_FILE}' n√£o encontrado!")
        print("   Voc√™ precisa baixar as credenciais do Google Cloud Console.")
        return False
    else:
        print(f"‚úÖ Arquivo '{CLIENT_SECRETS_FILE}' encontrado.")
    
    return True

def authenticate():
    """Lida com a autentica√ß√£o do usu√°rio e retorna o servi√ßo da API."""
    print("üîê Iniciando processo de autentica√ß√£o...")
    
    creds = None
    # O arquivo token.json armazena os tokens de acesso e atualiza√ß√£o do usu√°rio.
    if os.path.exists('token.json'):
        print("‚úÖ Arquivo token.json encontrado. Carregando credenciais...")
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    
    # Se n√£o houver credenciais v√°lidas, permite que o usu√°rio fa√ßa login.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            print("üîÑ Atualizando credenciais expiradas...")
            creds.refresh(Request())
        else:
            print("üåê Iniciando fluxo de autentica√ß√£o no navegador...")
            flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRETS_FILE, SCOPES)
            creds = flow.run_local_server(port=0)
        
        # Salva as credenciais para a pr√≥xima execu√ß√£o
        print("üíæ Salvando credenciais...")
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
            
    try:
        service = build('drive', 'v3', credentials=creds)
        print("‚úÖ Autentica√ß√£o com Google Drive bem-sucedida!")
        return service
    except HttpError as error:
        print(f"‚ùå Erro ao construir o servi√ßo da API: {error}")
        return None

# =========================================================================
# üß† C√âREBRO DEFINITIVO - PARSER INTELIGENTE COM REGEX
# =========================================================================
def parse_synapse_output(text):
    """
    Analisa a sa√≠da completa e estruturada do Professor Synapse,
    convertendo-a em uma lista de c√©lulas prontas para o Google Colab.
    """
    print("üìù Analisando a estrutura completa e complexa da aula...")
    print("üéØ Usando parser inteligente com regex avan√ßado...")

    # ETAPA 1: Pr√©-filtragem - Remove a se√ß√£o "Mergulhos Adicionais"
    original_length = len(text)
    if "üåä Mergulhos Adicionais Opcionais" in text:
        text = text.split("üåä Mergulhos Adicionais Opcionais")[0]
        print("‚úÖ Se√ß√£o 'Mergulhos Adicionais' removida com sucesso.")
        print(f"   üìä Texto reduzido de {original_length} para {len(text)} caracteres")
    else:
        print("‚ÑπÔ∏è  Se√ß√£o 'Mergulhos Adicionais' n√£o encontrada (normal se n√£o existir)")

    # ETAPA 2: Regex para encontrar todos os tipos de blocos que nos interessam.
    # Esta regex "ca√ßa" blocos de markdown ou pares de c√≥digo/texto.
    # Padr√£o 1: Bloco de Markdown geral (```markdown)
    # Padr√£o 2: Bloco de C√≥digo (‚ñ∂Ô∏è ... ```python)
    # Padr√£o 3: Bloco de Texto de Leitura (üìñ ... ```markdown)
    
    print("üîç Iniciando busca por padr√µes com regex...")
    
    pattern = re.compile(
        r"(```markdown\n(.*?)\n```)|(‚ñ∂Ô∏è.*?```python\n(.*?)\n```)|(üìñ.*?```markdown\n(.*?)\n```)", 
        re.DOTALL
    )
    
    matches = list(pattern.finditer(text))
    print(f"üéØ Encontrados {len(matches)} blocos v√°lidos para processamento")
    
    cells = []
    code_blocks_found = 0
    markdown_blocks_found = 0
    reading_blocks_found = 0
    
    for i, match in enumerate(matches):
        print(f"üìÑ Processando bloco {i+1}/{len(matches)}...")
        
        # O resultado do match nos diz qual grupo foi encontrado
        # match.group(2) -> Bloco de Markdown geral
        # match.group(4) -> Bloco de C√≥digo Python
        # match.group(6) -> Bloco de Texto de Leitura
        
        if match.group(2):
            # Bloco de Markdown geral (teoria, t√≠tulos, etc.)
            content = match.group(2).replace('<br>', '').strip()
            cells.append({'type': 'markdown', 'content': content})
            markdown_blocks_found += 1
            print(f"   üìñ Markdown adicionado: {len(content)} caracteres")
        
        elif match.group(4):
            # Bloco de C√≥digo Python
            content = match.group(4).strip()
            # Adiciona a c√©lula de c√≥digo
            cells.append({'type': 'code', 'content': content})
            # >>> AQUI EST√Å A SUA FUNCIONALIDADE ESPECIAL <<<
            # Adiciona a c√©lula de c√≥digo em branco para pr√°tica
            cells.append({'type': 'code', 'content': '# Pratique seu c√≥digo aqui!'})
            code_blocks_found += 1
            print(f"   ‚ö° C√≥digo adicionado: {len(content)} caracteres")
            print(f"   üéØ C√©lula de pr√°tica adicionada!")
            
        elif match.group(6):
            # Bloco de Texto de Leitura
            content = match.group(6).strip()
            cells.append({'type': 'markdown', 'content': content})
            reading_blocks_found += 1
            print(f"   üìö Texto de leitura adicionado: {len(content)} caracteres")

    # ETAPA 3: Verifica√ß√£o e estat√≠sticas finais
    if not cells:
        print("‚ùå ERRO: Nenhum bloco v√°lido foi encontrado!")
        print("üîß Poss√≠veis causas:")
        print("   1. A estrutura do prompt pode ter mudado")
        print("   2. O texto n√£o cont√©m os padr√µes esperados (```markdown, ‚ñ∂Ô∏è, üìñ)")
        print("   3. Formata√ß√£o incorreta dos blocos de c√≥digo")
        print("\nüîç Mostrando uma amostra do texto para diagn√≥stico:")
        print("-" * 50)
        sample = text[:1000] + "..." if len(text) > 1000 else text
        print(sample)
        print("-" * 50)
        return []
    else:
        print("\n" + "=" * 60)
        print("‚úÖ AN√ÅLISE CONCLU√çDA COM SUCESSO!")
        print("=" * 60)
        print(f"üìä ESTAT√çSTICAS DETALHADAS:")
        print(f"   üî¢ Total de c√©lulas criadas: {len(cells)}")
        print(f"   üìñ Blocos de markdown (teoria): {markdown_blocks_found}")
        print(f"   üìö Blocos de leitura: {reading_blocks_found}")
        print(f"   ‚ö° Blocos de c√≥digo: {code_blocks_found}")
        print(f"   üéØ C√©lulas de pr√°tica: {code_blocks_found}")
        print("=" * 60)
        
    return cells

def create_notebook_structure(cells_data):
    """Cria a estrutura JSON de um notebook .ipynb a partir dos dados das c√©lulas."""
    print("üèóÔ∏è Criando estrutura do notebook...")
    
    notebook_cells = []
    for cell_item in cells_data:
        if cell_item['type'] == 'code':
            notebook_cells.append({
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [line + '\n' for line in cell_item['content'].split('\n')]
            })
        elif cell_item['type'] == 'markdown':
            notebook_cells.append({
                "cell_type": "markdown",
                "metadata": {},
                "source": [line + '\n' for line in cell_item['content'].split('\n')]
            })
            
    notebook_json = {
        "nbformat": 4,
        "nbformat_minor": 0,
        "metadata": {
            "colab": {
                "provenance": []
            },
            "kernelspec": {
                "name": "python3",
                "display_name": "Python 3"
            },
            "language_info": {
                "name": "python"
            }
        },
        "cells": notebook_cells
    }
    
    print(f"‚úÖ Estrutura do notebook criada com {len(notebook_cells)} c√©lulas.")
    return json.dumps(notebook_json, indent=2)

def main():
    """Fun√ß√£o principal que orquestra todo o processo."""
    print("üöÄ INICIANDO AGENTE DE PREPARA√á√ÉO DO COLAB")
    # obt√©m link e aula pela interface gr√°fica
    obter_dados_via_gui()
    notebook_link = GUI_LINK
    synapse_output = GUI_AULA
    print("=" * 70)
    print("üìÖ Vers√£o: DEFINITIVA - Parser Inteligente")
    print("üß† C√©rebro: Regex Avan√ßado para Estruturas Complexas")
    print("üéØ Especialidade: Modo Aula do Professor Synapse")
    print("üë§ Desenvolvido para: Transformar Aulas em Notebooks Interativos")
    print("=" * 70)
    
    # Verificar arquivos necess√°rios
    if not check_requirements():
        print("\n‚ùå Pr√©-requisitos n√£o atendidos. Abortando.")
        input("Pressione Enter para sair...")
        return
    
    # Autenticar
    service = authenticate()
    if not service:
        print("\n‚ùå Falha na autentica√ß√£o. Abortando.")
        input("Pressione Enter para sair...")
        return

    print("\n" + "=" * 70)
    
    # 1. Obter o ID do notebook do Google Colab
    print("üìé PASSO 1: IDENTIFICAR O NOTEBOOK")
    print("-" * 35)
    
    
    # Verifica qual formato de URL foi usado e extrai o ID corretamente
    notebook_id = None
    
    print("üîç Analisando o link fornecido...")
    
    if '/d/' in notebook_link:
        try:
            notebook_id = notebook_link.split('/d/')[1].split('/')[0]
            print("‚úÖ ID extra√≠do usando padr√£o '/d/'")
        except IndexError:
            pass
    elif '/drive/' in notebook_link:
        try:
            # Para URLs do tipo: https://colab.research.google.com/drive/ID
            notebook_id = notebook_link.split('/drive/')[1].split('/')[0].split('#')[0].split('?')[0]
            print("‚úÖ ID extra√≠do usando padr√£o '/drive/'")
        except IndexError:
            pass
    
    # Se n√£o conseguiu extrair o ID, tenta outros padr√µes comuns
    if not notebook_id:
        print("‚ö†Ô∏è  Tentando padr√µes alternativos...")
        # Tenta extrair usando regex para capturar IDs do Google Drive
        id_pattern = r'[a-zA-Z0-9_-]{25,}'
        matches = re.findall(id_pattern, notebook_link)
        if matches:
            # Pega o primeiro match que parece ser um ID v√°lido do Google Drive
            for match in matches:
                if len(match) >= 25:  # IDs do Google Drive geralmente t√™m pelo menos 25 caracteres
                    notebook_id = match
                    print("‚úÖ ID extra√≠do usando regex")
                    break
    
    if not notebook_id:
        print("‚ùå ERRO: N√£o foi poss√≠vel extrair o ID do notebook do link fornecido.")
        print("   Certifique-se de que voc√™ copiou o link completo do Google Colab.")
        print("   Exemplo: https://colab.research.google.com/drive/SEU_ID_AQUI")
        input("Pressione Enter para sair...")
        return

    print(f"‚úÖ ID do Notebook identificado: {notebook_id}")
        
    # 2. Obter a sa√≠da do Professor Synapse
    print("\n" + "=" * 70)
    print("üìö PASSO 2: COLAR AULA COMPLETA DO PROFESSOR SYNAPSE")
    print("-" * 35)
    print("üìù Cole TODA a aula do Professor Synapse (Modo Aula) abaixo.")
    print("   üß† PARSER INTELIGENTE: Detecta automaticamente:")
    print("   üìñ Teoria e explica√ß√µes (markdown)")
    print("   ‚ö° C√≥digos execut√°veis (python)")
    print("   üìö Textos de leitura")
    print("   üéØ Adiciona c√©lulas de pr√°tica ap√≥s cada c√≥digo!")
    print("   üö´ Remove automaticamente 'Mergulhos Adicionais'")
    print("   Dica: Ctrl+V para colar, depois pressione:")
    print("   ‚Ä¢ Windows: Ctrl+Z e Enter")
    print("   ‚Ä¢ Linux/Mac: Ctrl+D")
    print("-" * 70)
    
    
    line_count = 0
    
    
    
    print(f"‚úÖ Conte√∫do colado: {line_count} linhas, {len(synapse_output)} caracteres")
            
    if not synapse_output.strip():
        print("‚ùå Nenhum conte√∫do foi colado. Abortando.")
        input("Pressione Enter para sair...")
        return
        
    # 3. Parsear o conte√∫do e criar a estrutura do notebook
    print("\n" + "=" * 70)
    print("‚öôÔ∏è  PASSO 3: PROCESSANDO COM PARSER INTELIGENTE")
    print("-" * 35)
    
    parsed_cells = parse_synapse_output(synapse_output)
    if not parsed_cells:
        print("‚ùå N√£o foi poss√≠vel processar o conte√∫do.")
        print("   O parser inteligente n√£o encontrou padr√µes v√°lidos.")
        input("Pressione Enter para sair...")
        return
        
    new_notebook_content = create_notebook_structure(parsed_cells)
    
    # 4. Salvar o conte√∫do em um arquivo tempor√°rio
    temp_filename = 'temp_notebook.ipynb'
    print(f"üíæ Salvando conte√∫do tempor√°rio em '{temp_filename}'...")
    
    try:
        with open(temp_filename, 'w', encoding='utf-8') as f:
            f.write(new_notebook_content)
        print("‚úÖ Arquivo tempor√°rio criado com sucesso!")
    except Exception as e:
        print(f"‚ùå Erro ao criar arquivo tempor√°rio: {e}")
        input("Pressione Enter para sair...")
        return
        
    # 5. Fazer o upload e substituir o arquivo no Google Drive
    print("\n" + "=" * 70)
    print("üö® PASSO 4: CONFIRMA√á√ÉO FINAL")
    print("-" * 35)
    print("‚ö†Ô∏è  ATEN√á√ÉO: Esta opera√ß√£o ir√° SUBSTITUIR completamente o conte√∫do atual do notebook!")
    print(f"üìã Notebook ID: {notebook_id}")
    print(f"üìä C√©lulas a serem criadas: {len(parsed_cells)}")
    print("üéØ RESULTADO: Notebook interativo com teoria + pr√°tica!")
    print("-" * 70)
    
    confirm = input("Voc√™ tem ABSOLUTA CERTEZA que deseja continuar? (digite 'SIM' em mai√∫sculas): ")
    
    if confirm == 'SIM':
        try:
            print("\nüì§ Enviando aula completa para o Google Drive...")
            print("‚è≥ Aguarde, isso pode levar alguns segundos...")
            
            media = MediaFileUpload(temp_filename, mimetype='application/vnd.google-colaboratory')
            result = service.files().update(
                fileId=notebook_id,
                media_body=media
            ).execute()
            
            print("\nüéâ SUCESSO TOTAL!")
            print("=" * 70)
            print("‚úÖ Seu notebook no Google Colab foi atualizado com PARSER INTELIGENTE!")
            print("üß† Estrutura complexa processada com sucesso!")
            print("üìö Cont√©m: Teoria + C√≥digos + C√©lulas de Pr√°tica")
            print("üö´ Mergulhos Adicionais removidos automaticamente")
            print("üí° IMPORTANTE: Recarregue a p√°gina do Colab para ver as mudan√ßas.")
            print(f"üîó Link direto: https://colab.research.google.com/drive/{notebook_id}")
            print("=" * 70)
            
        except HttpError as error:
            print(f"\n‚ùå ERRO ao atualizar o arquivo: {error}")
            print("üîß Poss√≠veis solu√ß√µes:")
            print("   1. Verifique se o ID do notebook est√° correto")
            print("   2. Certifique-se de que tem permiss√£o para editar o notebook")
            print("   3. Tente executar o script novamente")
            
        finally:
            # Limpeza do arquivo tempor√°rio
            try:
                time.sleep(0.5)
                os.remove(temp_filename)
                print(f"üßπ Arquivo tempor√°rio '{temp_filename}' removido.")
            except (PermissionError, FileNotFoundError):
                print(f"‚ÑπÔ∏è  O arquivo tempor√°rio '{temp_filename}' ser√° removido automaticamente.")
    else:
        print("\n‚ùå Opera√ß√£o cancelada pelo usu√°rio.")
        print("   Para confirmar, voc√™ deve digitar exatamente 'SIM' em mai√∫sculas.")
        try:
            os.remove(temp_filename)
            print(f"üßπ Arquivo tempor√°rio '{temp_filename}' removido.")
        except (PermissionError, FileNotFoundError):
            pass
    
    print("\n" + "=" * 70)
    print("üèÅ AGENTE DE PREPARA√á√ÉO DO COLAB - VERS√ÉO DEFINITIVA")
    print("=" * 70)
    input("Pressione Enter para sair...")

# ESTA √â A PARTE MAIS IMPORTANTE - A CHAMADA DA FUN√á√ÉO MAIN
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Opera√ß√£o interrompida pelo usu√°rio (Ctrl+C).")
        print("üëã At√© logo!")
    except Exception as e:
        print(f"\nüí• ERRO INESPERADO: {e}")
        print("üîß Por favor, verifique se todas as depend√™ncias est√£o instaladas:")
        print("   pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
        input("Pressione Enter para sair...")